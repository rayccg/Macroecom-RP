[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Effects of Fiscal Policy on Unemployment and Output in Australia: a Bayesian SVAR Approach",
    "section": "",
    "text": "Abstract. This proposed study attempts to estimate the effects of fiscal policy instruments on unemployment and output in Australia, using Bayesian Structural Vector Autoregression (BSVAR) models that account for conditional heteroskedasticity. Impulse response functions are used for measuring these effects.\nKeywords. Fiscal policy, unemployment, GDP, Australia impulse response, COVID-19, R"
  },
  {
    "objectID": "index.html#a-simple-example",
    "href": "index.html#a-simple-example",
    "title": "Title of your work",
    "section": "A Simple Example",
    "text": "A Simple Example\nThis is a Quarto document in which we can cite the bsvars package by Woźniak (2022). Look for more info at package CRAN website.\nSimply load the package by running\n\n\n\nThe code below performs simple computations for sampling posterior draws of the impulse responses. The first line uploads the data from the package,another sets the seed for reproducible computations, and then the pipe |> is used to streamline the model specification, estimation including the first burn-in run to obtain convergence and finally, the computed impulse responses are saved in object irf.\n\ndata(us_fiscal_lsuw)\nset.seed(123)\nus_fiscal_lsuw |>\n  specify_bsvar$new(p = 1) |>\n  estimate(S = 1000, show_progress = FALSE) |> \n  estimate(S = 2000, show_progress = FALSE) |> \n  compute_impulse_responses(horizon = 20) -> irf\n\nThe code above is visible as the R chunk contains the setting #| echo: true.\nTable 1 reports the posterior means of the gross domestic product response to an unanticipated tax increase by 1 pp.\n\n\n\n\nTable 1: Impulse response of gdp to unanticipated tax increase by 1 pp. within two years\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n\nchange in gdp [%]\n0.199\n0.184\n0.17\n0.159\n0.148\n0.139\n0.13\n0.123\n0.116\n\n\n\n\n\n\nFigure 1 presents the same reaction over the horizon of five years.\n\n\n\n\n\nFigure 1: Impulse response of gdp to unanticipated tax increase by 1 pp. within five years"
  },
  {
    "objectID": "index.html#some-hints",
    "href": "index.html#some-hints",
    "title": "Title of your work",
    "section": "Some Hints",
    "text": "Some Hints\nHave a look at how to work with RStudio and GitHub at: How to use git and GitHub with R.\nThese are many different ways of how to work with references in RStudio: Preview Citations.\nTo make all the R code visible on the website change the settings in the preabmble of this document to:\nexecute:\n  echo: true"
  },
  {
    "objectID": "Macro_RP1 RG.html",
    "href": "Macro_RP1 RG.html",
    "title": "Effects of fiscal policy on unemployment and output in Australia: a Bayesian Structural Vector Autoregression approach",
    "section": "",
    "text": "Abstract. This study attempts to estimate the effect of different fiscal policy instruments on unemployment and output in Australia, using a Bayesian Structural Vector Autoregression approach. Impulse response functions and forecast variance error decomposition methods are used to analyze these effects.\nKeywords. bsvars, fiscal policy, unemployment, GDP, impulse response, forecast variance error decomposition, Australia"
  },
  {
    "objectID": "Macro_RP1 RG.html#introduction",
    "href": "Macro_RP1 RG.html#introduction",
    "title": "Effects of fiscal policy on unemployment and output in Australia: a Bayesian Structural Vector Autoregression approach",
    "section": "Introduction",
    "text": "Introduction\nIn many countries, fiscal policy is viewed as a direct means of achieving inclusive development objectives, frequently articulated as twin goals of sustained growth and low poverty (often achieved through low unemployment). However, fiscal policy shocks often occur in multifaceted ways, with simultaneous changes in both revenue and expenditure-side elements of the fiscal balance, making it difficult to disentangle the effects of any one particular policy.\nThis study attempts to identify the effect of the following fiscal policy instruments: tax policy, public investment expenditures, and social transfers, on both unemployment and output in the Australian context, using Bayesian Structural Vector Autoregression (BSVAR) approach.\nThe analysis is guided by the work of Abubakar, Attahir B. (2016), which used a SVAR approach to estimate the effect of public expenditures and public revenues on Nigerian output and unemployment. This study extends this work by using a more extensive dataset, involving more disaggregated revenue and expenditure variables, the inclusion of monetary policy control variables, as well as through the use of Bayesian estimation."
  },
  {
    "objectID": "Macro_RP1 RG.html#data-sources",
    "href": "Macro_RP1 RG.html#data-sources",
    "title": "Effects of fiscal policy on unemployment and output in Australia: a Bayesian Structural Vector Autoregression approach",
    "section": "Data sources",
    "text": "Data sources\nQuarterly data from Q1 1990 to Q4 2022 was sourced from the Australian Bureau of Statistics and the Reserve Bank of Australia and extracted using the readabs and readrba packages in R.\nOutcome variables:\n\nUnemployment rate and nominal GDP\n\nExplanatory variables of interest\n\nRevenue: Tax and non-tax (gross income less tax) revenue\nSpending: Public gross fixed capital formation and social assistance payments, government final consumption\n\nControl variables:\n\nMonetary policy: cash rate target and M3 money supply\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n\n\nAs seen in the figures below, Australian GDP output has been on a relatively steady, upward trend since 1990, along with fiscal revenue and spending. These have been largely accommodated by lowering of interest rates and an expanding money supply. Overall, these have been associated with a downward, albeit volatile trajectory in the unemployment rate. Following the advice of Doppelt (2021), the data is left in original, seasonally-unadjusted form but will be transformed into natural log terms during the analysis.\n\nTime series plots: 1990 Q1 to 2022 Q4, original values"
  },
  {
    "objectID": "Macro_RP1 RG.html#preliminary-data-analysis",
    "href": "Macro_RP1 RG.html#preliminary-data-analysis",
    "title": "Effects of fiscal policy on unemployment and output in Australia: a Bayesian Structural Vector Autoregression approach",
    "section": "Preliminary data analysis",
    "text": "Preliminary data analysis\n\nACF and PACF analysis\nACF plots show strong, positive, and gradually decaying autocorrelation structures across all variables. Moreover the PACF plots indicate a near-one value at the first lag and much lower, mostly statistically zero values at higher lag orders. These characteristics may be indicating that the variables are following a random walk with drift process and as such may be unit-root non-stationary.\n\nAutocorrelation function (ACF) plots\n\n\n\n\n\n\n\nPartial autocorrelation function (PACF) plots\n\n\n\n\n\n\n\n\nAugmented Dickey-Fuller test for unit roots\n\n\n\n\nADF test results: levels, first, and second difference\n\n\n\n\n  \n\n\n\nAugmented Dickey-Fuller tests following the maximum lag-setting procedure of Ng and Perron (1998) were performed on all nine variables. The null hypothesis that a unit roots exists was rejected for ADF tests on levels of tax revenue, non-tax revenue, social benefits payments, government consumption, and M3 supply, indicating that these variables do not have a unit-root. Meanwhile, the first differences of the unemployment rate, government GFCF, and M3 supply variables yielded a significant ADF test result, indicating that these have order of integration of 1. Lastly, it took another differening for nominal GDP to yield a significant result, indicating an order of integration of 2. ## Model specification\n\n\n\nStructural form (SF) model\nThe following SVAR model is specified to represent the system through which the included variables are jointly determined:\n\\[\n\\begin{align}\nB_0y_t &= b_0 + B_1 y_{t-1} + \\dots + b_p y_{t-p} + u_t\\\\\nu_{t}| Y_{t-1} &\\sim _{iid} ( 0, I_N)\n\\end{align}\n\\] Where \\(y_t\\) is a vector of endogenous variables:\n\\[y_t=\\begin{pmatrix} unemp_t &= \\text{unemployment rate}\n\\\\ nomgdp_t &= \\text{nominal GDP}\n\\\\ totaltax_t  &= \\text{tax revenue}\n\\\\ nontax_t  &= \\text{non-tax revenue}\n\\\\ pubinv_t  &= \\text{government gross fixed capital formation}\n\\\\ pubtrans_t  &= \\text{social assitance and benefits payments}\n\\\\ pubcons_t  &= \\text{government final consumption}\n\\\\ cashrate_t  &= \\text{cash rate target}\n\\\\ M3_t  &= \\text{M3 money supply}\n\\end{pmatrix}\\]\nand the structural matrix \\(B_0\\) summarizes the contemporaneous relationships between these variables.\n\n\nReduced form (RF) model\n\\[\n\\begin{align}\ny_t &= \\mu_0 + A_1 y_{t-1} + \\dots + A_p y_{t-p} + \\varepsilon_t\\\\\n\\text{where }B_0^{-1}u_t &= \\varepsilon_t| Y_{t-1} \\sim _{iid} ( 0, \\Sigma)\\\\\n\\Sigma &= B_0^{-1}B_0^{-1'}\n\\end{align}\n\\]\nThe study will utilize impulse response functions and forecast error variance decomposition methods to measure the effects of the four fiscal levers in the model on the unemployment rate and GDP output."
  },
  {
    "objectID": "Macro_RP1 RG.html#model-specification",
    "href": "Macro_RP1 RG.html#model-specification",
    "title": "Effects of fiscal policy on unemployment and output in Australia: a Bayesian Structural Vector Autoregression approach",
    "section": "Model specification",
    "text": "Model specification\n\nStructural form (SF) model\nThe following SVAR model is specified to represent the system through which the included variables are jointly determined:\n\\[\n\\begin{align}\nB_0y_t &= b_0 + B_1 y_{t-1} + \\dots + b_p y_{t-p} + u_t\\\\\nu_{t}| Y_{t-1} &\\sim _{iid} ( 0, I_N)\n\\end{align}\n\\] Where \\(y_t\\) is a vector of endogenous variables:\n\\[y_t=\\begin{pmatrix} unemp_t &= \\text{unemployment rate}\n\\\\ nomgdp_t &= \\text{nominal GDP}\n\\\\ totaltax_t  &= \\text{tax revenue}\n\\\\ nontax_t  &= \\text{non-tax revenue}\n\\\\ pubinv_t  &= \\text{government gross fixed capital formation}\n\\\\ pubtrans_t  &= \\text{social assitance and benefits payments}\n\\\\ pubcons_t  &= \\text{government final consumption}\n\\\\ cashrate_t  &= \\text{cash rate target}\n\\\\ M3_t  &= \\text{M3 money supply}\n\\end{pmatrix}\\]\nand the structural matrix \\(B_0\\) summarizes the contemporaneous relationships between these variables.\n\n\nReduced form (RF) model\n\\[\n\\begin{align}\ny_t &= \\mu_0 + A_1 y_{t-1} + \\dots + A_p y_{t-p} + \\varepsilon_t\\\\\n\\text{where }B_0^{-1}u_t &= \\varepsilon_t| Y_{t-1} \\sim _{iid} ( 0, \\Sigma)\\\\\n\\Sigma &= B_0^{-1}B_0^{-1'}\n\\end{align}\n\\]\nThe study will utilize impulse response functions and forecast error variance decomposition methods to measure the effects of the four fiscal levers in the model on the unemployment rate and GDP output."
  },
  {
    "objectID": "Macro_RP1 RG.html#references",
    "href": "Macro_RP1 RG.html#references",
    "title": "Effects of fiscal policy on unemployment and output in Australia: a Bayesian Structural Vector Autoregression approach",
    "section": "References",
    "text": "References\nAbubakar, Attahir B. (2016): Dynamic effects of fiscal policy on output and unemployment in Nigeria: An econometric investigation, CBN Journal of Applied Statistics, ISSN 2476-8472, The Central Bank of Nigeria, Abuja, Vol. 07, Iss. 2, pp. 101-122\nDoppelt, Ross (2021): Should Macroeconomists Use Seasonally Adjuted Time Series? Structural Identification and Bayesian Estimation in Seasonal Vector Autoregressions, Manuscript, Michigan State University"
  },
  {
    "objectID": "index.html#introduction",
    "href": "index.html#introduction",
    "title": "Effects of Fiscal Policy on Unemployment and Output in Australia: a Bayesian SVAR Approach",
    "section": "Introduction",
    "text": "Introduction\nIn many countries, fiscal policy is viewed as a direct means of achieving inclusive development objectives, frequently articulated as twin goals of sustained growth and low poverty (often achieved through low unemployment). However, fiscal policy shocks often occur in multifaceted ways, with simultaneous changes in both revenue and expenditure-side elements of the fiscal balance. This makes it difficult to disentangle the effects of any one particular policy shock.\nThis study attempts to identify the effect of the following fiscal policy instrument: tax policy, public investment expenditures, and social transfers, on both unemployment and output in the Australian context, using a Bayesian Structural Vector Autoregression (BSVAR) approach.\nThe analysis is inspired by the work of Abubakar (2016), which used an SVAR approach to estimate the effect of public expenditures and public revenues on Nigerian output and unemployment, Lenza and Primiceri (2022) which proposes an estimation procedure for VARs after the COVID-19 pandemic, and the common stochastic volatility model framework of Jacquier and Rossi (1994). This study extends their work by using a more extensive data set, containing disaggregated revenue and expenditure variables, the inclusion of monetary policy control variables, and by applying the respective volatility models into a structural analysis.\nThe author acknowledges and deeply thanks Dr. Tomasz Woźniak for generously providing tireless support, guidance, and baseline R codes on which the full script of the analysis was built upon."
  },
  {
    "objectID": "index.html#data-sources",
    "href": "index.html#data-sources",
    "title": "Effects of Fiscal Policy on Unemployment and Output in Australia: a Bayesian SVAR Approach",
    "section": "Data sources",
    "text": "Data sources\nQuarterly data from Q1 1990 to Q4 2022 was sourced from the Australian Bureau of Statistics (ABS) and the Reserve Bank of Australia (RBA). These were extracted using the readabs and readrba packages in R.\nUnemployment rate and nominal GDP data are viewed as the outcome variables while tax revenue, public gross fixed capital formation (i.e., public investment) and government social assistance payments (i.e., social subsidies) are the explanatory variables of interest. Government final consumption is included to control for the effects of less productive, more routine government spending. Lastly, non-tax revenue (which, arguably, have a less distortionary effect on markets compared to taxes) and monetary policy reflected through the cash rate target and M3 money supply are also controlled for to mitigate omitted variable issues.\nOutcome variables:\n\nUnemployment rate and nominal GDP\n\nExplanatory variables of interest\n\nRevenue: Tax revenue\nSpending: Public gross fixed capital formation and social assistance payments\n\nControl variables:\n\nOther fiscal policies: non-tax (gross income less tax) revenue, government final consumption\nMonetary policy: cash rate target and M3 money supply\nExternal sector: real exchange rate\n\n\nTable 1. Data from ABS and RBA"
  },
  {
    "objectID": "index.html#preliminary-data-analysis",
    "href": "index.html#preliminary-data-analysis",
    "title": "Effects of Fiscal Policy on Unemployment and Output in Australia: a Bayesian SVAR Approach",
    "section": "Preliminary data analysis",
    "text": "Preliminary data analysis\n\nACF and PACF analysis\nAcross variables (which have been transformed into natural log terms), ACF plots show a strong, positive, and gradually decaying autocorrelation structure. Moreover the PACF plots show a near-one value at the first lag and statistically zero values at higher lag orders, indicating that these macroeconomic variables follow a random walk with drift process and are thereby unit-root non-stationary.\n\nFigure 2.1. Autocorrelation function (ACF) plots of variables in log terms\n\n\n\n\n\n\n\nFigure 2.2. Partial autocorrelation function (PACF) plots of variables in log terms\n\n\n\n\n\n\n\n\nAugmented Dickey-Fuller test for unit roots\n\n\n\n\nTable 2.1. ADF test results: levels\n\n\n\n\n  \n\n\n\n\n\nTable 2.2. ADF test results: first difference\n\n\n\n\n  \n\n\n\n\n\nTable 2.3. ADF test results: second difference"
  },
  {
    "objectID": "index.html#model-specification",
    "href": "index.html#model-specification",
    "title": "Effects of Fiscal Policy on Unemployment and Output in Australia: a Bayesian SVAR Approach",
    "section": "Model specification",
    "text": "Model specification\nThe use of fiscal policy to stimulate or regulate the economy follows the Keynesian approach generally practiced around the world (but especially in developing countries) to navigate economies through downturns or potential episodes of overheating, particularly in the short-run. The proposed model aims to investigate the effectiveness of these fiscal measures in managing growth and unemployment.\nEstimation proceeds through the following reduced form model:\n\\[\n\\begin{align}\nY &= XA + U\\\\\nU| X &\\sim _{iid} MN_{T\\times N}( 0, \\Sigma, \\Omega)\\\\\n\\Sigma &= B_0^{-1}B_0^{-1'}\n\\end{align}\n\\] where matrix \\(Y\\) contains vectors of endogenous variables \\(y_t\\):\n\\[y_t=\\begin{pmatrix} unemp_t &= \\text{unemployment rate}\n\\\\ realgdp_t &= \\text{real GDP}\n\\\\ totaltax_t  &= \\text{tax revenue}\n\\\\ nontax_t  &= \\text{non-tax revenue}\n\\\\ pubinv_t  &= \\text{government gross fixed capital formation}\n\\\\ pubtrans_t  &= \\text{social assitance and benefits payments}\n\\\\ pubcons_t  &= \\text{government final consumption}\n\\\\ cashrate_t  &= \\text{cash rate target}\n\\\\ M3_t  &= \\text{M3 money supply}\n\\end{pmatrix}\\]\nand \\(B_0^{-1}=B\\) is the matrix of contemporaneous effects between variables."
  },
  {
    "objectID": "index.html#references",
    "href": "index.html#references",
    "title": "Effects of Fiscal Policy on Unemployment and Output in Australia: a Bayesian SVAR Approach",
    "section": "References",
    "text": "References\nAbubakar, Attahir B. (2016): Dynamic effects of fiscal policy on output and unemployment in Nigeria: An econometric investigation, CBN Journal of Applied Statistics, ISSN 2476-8472, The Central Bank of Nigeria, Abuja, Vol. 07, Iss. 2, pp. 101-122"
  },
  {
    "objectID": "Macro_RP1.html",
    "href": "Macro_RP1.html",
    "title": "Effects of fiscal policy on unemployment and output in Australia: a Bayesian SVAR approach",
    "section": "",
    "text": "Abstract. This proposed study attempts to estimate the effects of various fiscal policy instruments on unemployment and output in Australia, using a Bayesian Structural Vector Autoregression approach. Impulse response functions and forecast variance error decomposition methods are expected to be used for measuring these effects.\nKeywords. Fiscal policy, unemployment, GDP, Australia impulse response, forecast variance error decomposition, bsvars, R"
  },
  {
    "objectID": "Macro_RP1.html#introduction",
    "href": "Macro_RP1.html#introduction",
    "title": "Effects of fiscal policy on unemployment and output in Australia: a Bayesian SVAR approach",
    "section": "Introduction",
    "text": "Introduction\nIn many countries, fiscal policy is viewed as a direct means of achieving inclusive development objectives, frequently articulated as twin goals of sustained growth and low poverty (often achieved through low unemployment). However, fiscal policy shocks often occur in multifaceted ways, with simultaneous changes in both revenue and expenditure-side elements of the fiscal balance, making it difficult to disentangle the effects of any one particular policy shock.\nThis study attempts to identify the effect of the following fiscal policy instruments: tax policy, public investment expenditures, and social transfers, on both unemployment and output in the Australian context, using a Bayesian Structural Vector Autoregression (BSVAR) approach.\nThe analysis is guided by the work of Abubakar, Attahir B. (2016), which used an SVAR approach to estimate the effect of public expenditures and public revenues on Nigerian output and unemployment. This study extends his work by using a more extensive dataset, containing more disaggregated revenue and expenditure variables, the inclusion of monetary policy control variables, as well as through the use of Bayesian estimation."
  },
  {
    "objectID": "Macro_RP1.html#data-sources",
    "href": "Macro_RP1.html#data-sources",
    "title": "Effects of fiscal policy on unemployment and output in Australia: a Bayesian SVAR approach",
    "section": "Data sources",
    "text": "Data sources\nQuarterly data from Q1 1990 to Q4 2022 was sourced from the Australian Bureau of Statistics (ABS) and the Reserve Bank of Australia (RBA) and extracted using the readabs and readrba packages in R.\nUnemployment rate and nominal GDP data are viewed as the outcome variables while tax revenue, public gross fixed capital formation (i.e., public investment) and government social assistance payments (i.e., social subsidies) are the explanatory variables of interest. Government final consumption is included to control for the effects of less productive, more routine government spending. Lastly, non-tax revenue (which, arguably, have a less distortive effect on markets compared to taxes) and monetary policy reflected through the cash rate target and M3 money supply are also controlled for to avoid omitted variable issues.\nOutcome variables:\n\nUnemployment rate and nominal GDP\n\nExplanatory variables of interest\n\nRevenue: Tax revenue\nSpending: Public gross fixed capital formation and social assistance payments\n\nControl variables:\n\nOther fiscal policies: non-tax (gross income less tax) revenue, government final consumption\nMonetary policy: cash rate target and M3 money supply\n\n\nTable 1. Data from ABS and RBA"
  },
  {
    "objectID": "Macro_RP1.html#preliminary-data-analysis",
    "href": "Macro_RP1.html#preliminary-data-analysis",
    "title": "Effects of fiscal policy on unemployment and output in Australia: a Bayesian SVAR approach",
    "section": "Preliminary data analysis",
    "text": "Preliminary data analysis\n\nACF and PACF analysis\nAcross variables (which have been transformed into natural log terms), ACF plots show strong, positive, and gradually decaying autocorrelation structures. Moreover various PACF plots indicate a near-one value at the first lag and much lower, mostly statistically zero values at higher lag orders (such as in nominal GDP, social benefits payments, government consumption, and M3). These characteristics may indicate that some variables may be following a random walk with drift process and as such may be unit-root non-stationary.\n\nFigure 2.1. Autocorrelation function (ACF) plots of variables in log terms\n\n\n\n\n\n\n\nFigure 2.2. Partial autocorrelation function (PACF) plots of variables in log terms\n\n\n\n\n\n\n\n\nAugmented Dickey-Fuller test for unit roots\n\n# function to implement the Ng and Perron (1998) ADF test procedure\nngperronADF <- function(y){\n  T <- length(y)\n  kmax <- ceiling(12*(((T-25)/100)^(1/4)))\n  k <- kmax + 1\n  # run test regression until t-statistic of kth lag > 1.6\n  t <- 0\n  while(abs(t) < 1.6){\n      k <- k - 1\n      adft <- ur.df(y, type = \"drift\", lags = k)\n      t <- as.numeric(adft@testreg$coefficients[k+2,][3])\n  }\n  adft_k <-ur.df(y, type = \"drift\", lags = k)\n  teststat <- adft_k@teststat[2]\n  cval <- adft_k@cval[2,2]\n  sig <- abs(teststat)>abs(cval)\n  return(list(\"stat\" = teststat,\"crit\" = cval,\"reject\" = sig))\n}\n\n\nTable 2. ADF test results: levels, first, and second difference"
  },
  {
    "objectID": "Macro_RP1.html#model-specification",
    "href": "Macro_RP1.html#model-specification",
    "title": "Effects of fiscal policy on unemployment and output in Australia: a Bayesian SVAR approach",
    "section": "Model specification",
    "text": "Model specification\nThe use of fiscal policy to stimulate or regulate the economy follows the Kenyesian approach generally practiced around the world (but especially in developing countries) to navigate economies through downturns or potential episodes of overheating, particularly in the short-run. The proposed model aims to investigate the effectiveness of these fiscal measures in managing growth and unemployment.\n\nStructural form (SF) model\nThe following SVAR model specification is proposed is to represent the system through which the included variables are jointly determined:\n\\[\n\\begin{align}\nB_0y_t &= b_0 + B_1 y_{t-1} + \\dots + b_p y_{t-p} + u_t\\\\\nu_{t}| Y_{t-1} &\\sim _{iid} ( 0, I_N)\n\\end{align}\n\\] Where \\(y_t\\) is a vector of endogenous variables:\n\\[y_t=\\begin{pmatrix} unemp_t &= \\text{unemployment rate}\n\\\\ nomgdp_t &= \\text{nominal GDP}\n\\\\ totaltax_t  &= \\text{tax revenue}\n\\\\ nontax_t  &= \\text{non-tax revenue}\n\\\\ pubinv_t  &= \\text{government gross fixed capital formation}\n\\\\ pubtrans_t  &= \\text{social assitance and benefits payments}\n\\\\ pubcons_t  &= \\text{government final consumption}\n\\\\ cashrate_t  &= \\text{cash rate target}\n\\\\ M3_t  &= \\text{M3 money supply}\n\\end{pmatrix}\\]\nand the structural matrix \\(B_0\\) summarizes the contemporaneous relationships between these variables.\n\n\nReduced form (RF) model\n\\[\n\\begin{align}\ny_t &= \\mu_0 + A_1 y_{t-1} + \\dots + A_p y_{t-p} + \\varepsilon_t\\\\\n\\text{where }B_0^{-1}u_t &= \\varepsilon_t| Y_{t-1} \\sim _{iid} ( 0, \\Sigma)\\\\\n\\Sigma &= B_0^{-1}B_0^{-1'}\n\\end{align}\n\\]\nThe reduced form of the model, where \\(B_0^{-1}\\) is the matrix of contemporaneous effects between variables, allows for model estimation. However, the identification strategy for \\(B_0^{-1}\\) is yet to be finalized, but will likely involve either exclusion restrictions or sign restrictions.\nThe study will utilize impulse response functions (IRF) and forecast error variance decomposition (FEVD) methods to measure the effects of the tax policy, public investment, and government social transfers on the unemployment rate and GDP output. IRFs are used to measure the dynamic, marginal effects of orthogonal shocks from the three fiscal levers of interest while FEVD intends to account for the share of explained variability in the outcome variables that can be attributed to explanatory variables of interest."
  },
  {
    "objectID": "Macro_RP1.html#references",
    "href": "Macro_RP1.html#references",
    "title": "Effects of fiscal policy on unemployment and output in Australia: a Bayesian SVAR approach",
    "section": "References",
    "text": "References\nAbubakar, Attahir B. (2016): Dynamic effects of fiscal policy on output and unemployment in Nigeria: An econometric investigation, CBN Journal of Applied Statistics, ISSN 2476-8472, The Central Bank of Nigeria, Abuja, Vol. 07, Iss. 2, pp. 101-122"
  },
  {
    "objectID": "index.html#estimation-and-identification",
    "href": "index.html#estimation-and-identification",
    "title": "Effects of Fiscal Policy on Unemployment and Output in Australia: a Bayesian SVAR Approach",
    "section": "Estimation and identification",
    "text": "Estimation and identification\n\nBasic model\nFor the basic model, the column-wise covariance matrix is set as \\(\\Omega=I_N\\). The likelihood function is expressed as:\n\\[P(Y,X|A,\\Sigma) \\propto det(\\Sigma)^{-\\frac{T}{2}} exp \\left\\{-\\frac{1}{2} tr \\left[ \\Sigma^{-1}(Y-XA)'(Y-XA) \\right] \\right\\}\\\\\\] \\[=det(\\Sigma)^{-\\frac{T}{2}} exp \\left\\{-\\frac{1}{2} tr \\left[ \\Sigma^{-1}(A-\\hat{A})'X'X(A-\\hat{A}) \\right] \\right\\} exp \\left\\{-\\frac{1}{2} tr \\left[\\Sigma^{-1}(Y-X \\hat{A})'(Y-X \\hat{A}) \\right] \\right\\}\\]\nwhere the maximum likelihood estimators are expressed as:\n\\[\\hat{A} = (X'X)^{-1}X'Y \\] \\[\\hat{\\Sigma} = \\frac{1}{T} (Y-X \\hat{A})'(Y-X \\hat{A})\\]\nThe prior for \\(A\\) and \\(\\Sigma\\) is assumed to be a matrix-normal inverse Wishart distribution that follows the Minnesota specification of Doan, Litterman & Sims (1984):\n\\[p(A,\\Sigma) =MNIW(\\underline{A},\\underline{S},\\underline{V},\\underline{\\nu})\\]\n\\[A|\\Sigma\\sim MN_{K\\times N}(\\underline{A},\\Sigma,\\underline{V})\\] \\[\\Sigma\\sim IW_N(\\underline{S},\\underline{\\nu})\\]\nwhere:\n\\[\\underline{A} = [0_{N \\times 1} \\quad I_N \\quad 0_{N \\times (p-1)N}]'\\] \\[\\underline{V} = diag([\\kappa_2 \\quad \\kappa_1 (p^{-2} \\otimes I_N)])\\]\nThis leads to the following posterior distribution, from which the basic reduced form model will be estimated:\n\\[P(A|Y,X,\\Sigma)=MN_{K\\times N}(\\bar{A},\\Sigma,\\bar{V})\\] \\[P(\\Sigma|Y,X)=IW_N(\\bar{S},\\bar{\\nu})\\\\\\]\n\\[\\bar{V}=(X'X+\\underline{V}^{-1})^{-1}\\] \\[\\bar{A}=\\bar{V}(X'Y+\\underline{V}^{-1}\\underline{A})\\] \\[\\bar{\\nu}=T+\\underline{\\nu}\\] \\[\\bar{S}=\\underline{S}+Y'Y+\\underline{A}'\\underline{V}^{-1}\\underline{A}-\n\\bar{A}'\\bar{V}^{-1}\\bar{A}\\]\n\n\nCOVID volatility model\nFor the COVID volatility model, which explicitly attempts to model conditional heteroskedasticity beginning from the onset of the pandemic, the column-wise covariance matrix is set to \\(\\Omega=\\text{diag}(H^2)\\), where \\(H\\) is a vector of COVID volatility variables:\n\\[H=[1\\quad...\\quad1 \\quad h_0\\quad h_1\\quad h_2\\quad 1+(h_2-1)\\rho\\quad 1+(h_2-1)\\rho^2\\quad...]'\\]\nIntuitively, volatility variables for periods before COVID are set to unity. Heightened volatility during the first three quarters of COVID are parameterized, before they are assumed to decay gradually beginning at the fourth quarter since the pandemic’s onset.\nThese COVID volatility parameters \\(\\theta=(h_0\\quad h_1\\quad h_2\\quad\\rho)\\) are estimated from their own marginal posterior as proposed by Lenza & Primiceri (2020):\n\\[P(\\theta|Y,X,\\underline{\\gamma})\\propto P(Y,X|\\theta,\\underline{\\gamma})P(\\theta|\\underline{\\gamma})\\]\nwhere the likelihood function is given as:\n\\[P(Y,X|\\theta,\\underline{\\gamma})\\propto \\Bigg(\\prod^T_{t=1}h_t^{-N}\\Bigg)||\\underline{V}||^{\\frac{N}{2}}||\\underline{S}||^{\\frac{\\underline{\\nu}}{2}}||\\tilde{X}'\\tilde{X}+\\underline{V}^{-1}||^{\\frac{N}{2}}\\\\\\]\n\\[||\\underline{S}+\\hat{\\tilde{E}}'\\hat{\\tilde{E}}+(\\hat{\\tilde{A}}-\\tilde{Y}+\\tilde{X}\\underline{A})'\\underline{V}^{-1}(\\hat{\\tilde{A}}-\\tilde{Y}+\\tilde{X}\\underline{A})||^{-\\frac{T-p+\\underline{\\nu}}{2}}\\]\nwhere \\(\\tilde{X}_t=\\frac{(1,Y_t,...,Y_{t-p})'}{h_t}\\), \\(\\tilde{\\hat{A}}=(\\tilde{X}'\\tilde{X}-\\underline{V}^{-1})^{-1}\\), and \\(\\underline{\\gamma}=(\\underline{A},\\underline{S},\\underline{V},\\underline{\\nu})\\)\nand the priors are assumed to be: \\(h_0,h_1,h_2\\sim Pareto(1,1)\\) and \\(\\rho\\sim Beta(3,1.5)\\)\nSampling from the above posterior is conducted via the following Metropolis MCMC algorithm:\n\nInitialize \\(\\theta\\) at the posterior mode which was located via numerical optimization\nDraw candidate \\(\\theta^{*}\\) from \\(N_4(\\theta^{(s-1)},cW)\\), where \\(W\\) is the inverse Hessian of the negative log posterior of \\(\\theta\\) at the mode, which is also calculated computationally, and \\(c\\) is a scaling factor.\nSet:\n\n\\[\\theta^{(s)}=  \\begin{cases}\n        \\theta^* & \\text{with pr.} \\quad \\alpha^{(s)}\n        \\\\\n        \\\\\n        \\theta^{(s-1)} & \\text{with pr.} \\quad 1-\\alpha^{(s)}\n  \\end{cases}\\]\n\\[\\alpha^{(s)} =\\text{min}\\Big[1,\\frac{P(\\theta^*|Y,X,\\underline{\\gamma})}{P(\\theta^{(s-1)}|Y,X,\\underline{\\gamma})}\\Big]\\]\n\nDefine \\(H^{(s)}\\) matrix using \\(\\theta^{(s)}\\):\n\n\\[H^{(s)}=[1\\quad...\\quad1 \\quad h_0^{(s)}\\quad h_1^{(s)}\\quad h_2^{(s)}\\quad 1+(h_2^{(s)}-1)\\rho^{(s)}\\quad 1+(h_2^{(s)}-1)\\rho^{(s)2}\\quad...]'\\]\nSteps 2 to 4 are repeated \\(S_1+S_2\\) times and \\(S_2\\) draws are used to draw \\(A\\) and \\(\\Sigma\\) from the following posterior distribution:\n\\[P(A|Y,X,\\Sigma,H)=MN_{K\\times N}(\\bar{A},\\Sigma,\\bar{V})\\] \\[P(\\Sigma|Y,X,H)=IW_N(\\bar{S},\\bar{\\nu})\\\\\\]\n\\[\\bar{V}=(X'\\text{diag}(H^2)^{-1}X+\\underline{V}^{-1})^{-1}\\] \\[\\bar{A}=\\bar{V}(X'\\text{diag}(H^2)^{-1}Y+\\underline{V}^{-1}\\underline{A})\\] \\[\\bar{\\nu}=T+\\underline{\\nu}\\] \\[\\bar{S}=\\underline{S}+Y'\\text{diag}(H^2)^{-1}Y+\\underline{A}'\\underline{V}^{-1}\\underline{A}-\n\\bar{A}'\\bar{V}^{-1}\\bar{A}\\]\n\n\nCommon stochastic volatility model\nLastly, for the common volatility model the column-wise covariance matrix is set to \\(\\Omega=\\text{diag}(\\sigma^2)\\), where \\(\\sigma^2\\) is a vector of conditional heteroskedasticity variables:\n\\[\\sigma^2=[\\exp(h_0)\\quad\\exp(h_1)\\quad... \\quad \\exp(h_T)]'\\] These are estimated through the simple stochastic volatility model of Jacquier and Rossi (1994), where across each variable \\(y_t\\), the common volatility is estimated through:\n\\[\\tilde{y}=h+\\tilde{\\varepsilon}\\] \\[Hh=h_0e_{1.T}+\\sigma_vv\\] \\[\\tilde{\\varepsilon}\\sim \\log \\chi^2_1\\] \\[v\\sim\\mathcal{N}_T(0_T,I_T)\\] where:\n\\[\\tilde{y}=[\\log(y_1-\\mu_1(\\alpha))^2\\quad... \\quad \\log(y_T-\\mu_T(\\alpha))^2]'\\] \\[h=[h_1\\quad... \\quad h_T]'\\] \\[\\tilde{\\varepsilon}=[\\log\\varepsilon_1^2\\quad ...\\quad  \\log\\varepsilon_T^2]'\\] \\[v=[v_1\\quad... \\quad v_T]'\\] \\[e_{1.T}=[1\\quad 0\\quad... \\quad 0]'\\]\nUnder this framework, the likelihood function for the reduced form model is given by:\n\\[\\begin{gather}\nL(A,\\Sigma|Y,X,\\sigma^2) \\propto det(\\text{diag}(\\sigma^2))^{-\\frac{N}{2}} det(\\Sigma)^{-\\frac{T}{2}} exp \\left\\{-\\frac{1}{2} tr \\left[ \\Sigma^{-1}(Y-XA)'\\text{diag}(\\sigma^2)^{-1}(Y-XA) \\right] \\right\\} \\\\\n\\end{gather} \\]\nand the posterior distribution of \\(A\\) and \\(\\Sigma\\) is the following matrix-normal inverse Wishart distribution: \\[\\begin{gather}\nP(A,\\Sigma|X,Y,\\sigma^2) \\propto L(A,\\Sigma|Y,X,\\sigma^2) \\times  p(A|\\Sigma,\\sigma^2) \\times P(\\Sigma)\n\\end{gather}\\]\n\\[P(A|Y,X,\\Sigma,\\sigma^2)=MN_{K\\times N}(\\bar{A},\\Sigma,\\bar{V})\\] \\[P(\\Sigma|Y,X,\\sigma^2)=IW_N(\\bar{S},\\bar{\\nu})\\\\\\] with posterior parameters:\n\\[\\begin{gather}\n\\bar{V} = (X'\\text{diag}(\\sigma^2)^{-1}X+\\underline{V}^{-1})^{-1} \\\\\n\\\\ \\bar{A} = \\bar{V}(X'\\text{diag}(\\sigma^2)^{-1}Y+\\underline{V}^{-1}\\underline{A}) \\\\\n\\\\ \\bar{S} = \\underline{S} + Y'\\text{diag}(\\sigma^2)^{-1}Y + \\underline{A}^{'}\\underline{V}^{-1}\\underline{A} - \\bar{A}^{'}\\bar{V}^{-1}\\bar{A} \\\\\n\\\\ \\bar{\\nu}= T + \\underline{\\nu}\n\\end{gather}\\]\nObtaining draws from this posterior involves a Gibbs sampler, which follows the following algorithm:\n\nInitialize \\(h^{(0)}\\), \\(s^{(0)}\\), and \\(\\sigma^{2(0)}_v\\)\nDraw \\(h_0^{(s)}\\sim\\mathcal{N}(\\bar{h}_0,\\bar{\\sigma}^2_v)\\) where: \\(\\bar{\\sigma}^2_v=(\\underline{\\sigma}^{-2}_h+\\sigma^{-2}_v)\\) and \\(\\bar{h}_0=\\bar{\\sigma}^2_v(e'Hh)\\)\nDraw \\(\\sigma_v^{2(s)}\\sim\\mathcal{IG2}(\\bar{s},\\bar{\\nu})\\)\nDraw \\(s_t^{(s)}\\sim\\mathcal{Multiomial}(\\{m\\}^{10}_{m=1},\\{Pr[s_t=m|\\tilde{y},h_t^{(s)}]\\}^{10}_{m=1})\\) for all \\(s_t\\) in \\(s\\). These are used for the auxiliary normal mixture approximation of the chi-squared-1 distribution.\nDraw \\(h^{(s)}\\sim\\mathcal{N}_T(\\bar{h},\\bar{V}_h)\\) where \\(\\bar{V}_h=[\\text{diag}(\\sigma^2_s)^{-1}+\\sigma^{-2}_vH'H]^{-1}\\) and \\(\\bar{h}=\\bar{V}_h[\\text{diag}(\\sigma^2_s)^{-1}(\\tilde{y}-\\mu_s)+\\sigma^{-2}_vh_0e_{1.T}]\\)\nCompute vector \\(\\sigma^2=[\\exp(h_1^{(s)})\\quad...\\quad \\exp(h_T^{(s)})]\\)\nDraw \\((A,\\Sigma)\\sim\\mathcal{MNIW}(\\bar{A},\\bar{V},\\bar{S},\\bar{\\nu})\\) and use these to compute residuals \\(\\tilde{y}\\)\n\nSteps 2 to 7 are repeated for \\(S=S_1+S_2\\) draws, where \\(S_1\\) draws are discarded as burn-in and the latter \\(S_2\\) draws are kept as posterior draws.\n\n\nIdentification\nSign restrictions are used as the identification strategy for all models.\nGiven the reduced form model:\n\\[\n\\begin{align}\nY &= XA + U\\\\\nU| X &\\sim _{iid} MN_{T\\times N}( 0, \\Sigma, \\Omega)\\\\\n\\end{align}\n\\] For each draw from the reduced form posteriors, the candidate contemporaneous effects matrix is derived as: \\[\\tilde{B}=\\tilde{B}^{-1}_0=\\text{chol}(\\Sigma)\\]\nContemporaneous effects matrix \\(B\\) is identified by searching for an appropriate rotation matrix \\(Q\\) such that prescribed sign restrictions hold:\n\\[B = Q\\tilde{B}\\]\nsuch that:\n\\[R_nf(\\tilde{B}_0,\\tilde{B}_+)e_n\\geq0\\] \\[f(\\tilde{B}_0,\\tilde{B}_+)=\\Theta_0=\\tilde{B}^{-1}_0\\]\n\n\nEstimation with artificial data\nTo check the validity of the algorithms, two independent bi-variate random walk with drift processes were generated to simulate unit-root non-stationary macroeconomic variables.\n\n\n\n\n\nThe estimation procedure for the basic model is implemented in R by the following function, sign.basic:\n\n\nShow code\n# data = input data should be quarterly\n# p = lags\n# S = number of posterior draws\n# sign restritions = Nx1 diagonal of R matrix\n# k1 = kappa1\n# k2 = kappa2, higher value, less shrinkage, more weight on prior\n# shockvar = variable being shocked\n# start date = start date of Y matrix\nsign.basic <- function(data, p, S,  sign.restrictions,\n                           k1=0.04, k2=100, start_date = c(1991,1), shockvar=5){\n  # Define Y and X matrices\n  ############################################################\n  # N = no. of variables\n  N = ncol(data)\n  # p = no. of lags\n  K = 1 + p*N\n  # forecast horizon\n  # h       = 8\n  \n  Y       = ts(data[(p+1):nrow(data),], start=start_date, frequency=4)\n  X       = matrix(1,nrow(Y),1)\n  # nrow(X)\n  for (i in 1:p){\n    X     = cbind(X,data[(p+1):nrow(data)-i,])\n  }\n  \n  # Calculate MLE\n  ############################################################\n  A.hat       = solve(t(X)%*%X)%*%t(X)%*%Y\n  Sigma.hat   = t(Y-X%*%A.hat)%*%(Y-X%*%A.hat)/nrow(Y)\n  \n  # Specify prior distribution\n  ############################################################\n  kappa.1     = k1\n  kappa.2     = k2\n  kappa.3     = 1\n  A.prior     = matrix(0,nrow(A.hat),ncol(A.hat))\n  A.prior[2:(N+1),] = kappa.3*diag(N)\n  V.prior     = diag(c(kappa.2,kappa.1*((1:p)^(-2))%x%rep(1,N)))\n  S.prior     = diag(diag(Sigma.hat))\n  nu.prior    = N+1\n  \n  # Matrix normal-inverse Wishart posterior parameters\n  ############################################################\n  V.bar.inv   = t(X)%*%X + diag(1/diag(V.prior))\n  V.bar       = solve(V.bar.inv)\n  A.bar       = V.bar%*%(t(X)%*%Y + diag(1/diag(V.prior))%*%A.prior)\n  nu.bar      = nrow(Y) + nu.prior\n  S.bar       = S.prior + t(Y)%*%Y + t(A.prior)%*%diag(1/diag(V.prior))%*%A.prior - t(A.bar)%*%V.bar.inv%*%A.bar\n  S.bar.inv   = solve(S.bar)\n  \n  # Posterior draws \n  ############################################################\n  # Draws from RF posterior\n  # Draw Sigma from inverse wishart\n  Sigma.posterior   = rWishart(S, df=nu.bar, Sigma=S.bar.inv)\n  Sigma.posterior   = apply(Sigma.posterior,3,solve)\n  Sigma.posterior   = array(Sigma.posterior,c(N,N,S))\n  \n  # Draw A from matrix-variate normal\n  A.posterior       = array(rnorm(prod(c(dim(A.bar),S))),c(dim(A.bar),S))\n  \n  ## Draw from SF posterior\n  B0.posterior       = array(NA,c(N,N,S))\n  Bplus.posterior       = array(NA,c(N,K,S))\n  L                 = t(chol(V.bar))\n  for (s in 1:S){\n    # Draw B0\n    cholSigma.s     = chol(Sigma.posterior[,,s])\n    B0.posterior[,,s]= solve(t(cholSigma.s))\n    A.posterior[,,s]= A.bar + L%*%A.posterior[,,s]%*%cholSigma.s\n    # Draw Bplus\n    Bplus.posterior[,,s] = B0.posterior[,,s]%*%t(A.posterior[,,s])\n  }\n\n  # Identification via sign restrictions \n  ############################################################\n  \n  # Generate corresponding R matrix\n  R1 = diag(sign.restrictions)\n  \n  # Storage matrices for Q identified estimates\n  i.vec <- c()\n  Q.iden   = array(NA,c(N,N,S))\n  B0.iden = array(NA,c(N,N,S))\n  B1.iden = array(NA,c(N,K,S))\n  A.iden = array (NA,c(K,N,S))\n  \n  for (s in 1:S){\n    \n    # pick-up a B0 from S\n    B0.tilde <- B0.posterior[,,s]\n    IR.0.tilde    = solve(B0.tilde)\n    B1.tilde      = Bplus.posterior[,,s]\n    #IR.1.tilde    = solve(B0.tilde)%*%B1.tilde%*%solve(B0.tilde)\n\n    # Search for appropriate Q \n    sign.restrictions.do.not.hold = TRUE\n    i=1\n    while (sign.restrictions.do.not.hold){\n      X           = matrix(rnorm(N^2),N,N)\n      QR          = qr(X, tol = 1e-10)\n      Q           = qr.Q(QR,complete=TRUE)\n      R           = qr.R(QR,complete=TRUE)\n      Q           = t(Q %*% diag(sign(diag(R))))\n      B0          = Q%*%B0.tilde\n      B1          = Q%*%B1.tilde\n      B0.inv      = solve(B0)\n      check       = prod(R1 %*% B0.inv %*% diag(N)[,shockvar] >= 0)\n      A           = t(solve(B0)%*%B1)\n\n      if (check==1){sign.restrictions.do.not.hold=FALSE}\n      i=i+1\n    }\n    i.vec <- c(i.vec, i)\n    Q.iden[,,s] <- Q\n    B0.iden[,,s] <- B0\n    B0.mean <- apply(B0.iden,1:2,mean)\n    B1.iden[,,s] <- B1\n    B1.mean <- apply(B1.iden,1:2,mean)\n    A.iden[,,s] <- A\n    A.mean <- apply(A.iden,1:2,mean)\n    \n\n  }\n  re <- list(\"i\" = i.vec, \"Q\" = Q.iden, \"B0\"= B0.iden, \"B0.mean\" = B0.mean,\n             \"Bplus\"= B1.iden, \"Bplus.mean\" = B1.mean, \"A\" = A.iden, \"A.mean\" = A,\n             \"A.posterior\"=A.posterior, \"Sigma.posterior\"=Sigma.posterior)\n  return(re)\n}\n\n\nApplying the sign.basic function on the artificial returns the following matrices as estimates for the posterior means of \\(A\\) and \\(\\Sigma\\). These results are appropriate given the independent bivariate random walk with drift proceses:\n\n\n\n\n  \n\n\n\n\n\n  \n\n\n\nEstimating the COVID-volatility model involved designing three functions in R:\n\nv.posterior.mode takes in the data and numerically computes for the posterior mode of \\(\\theta\\), i.e., COVID volatility parameters;\n\n\n\nShow code\nv.posterior.mode <- function(data, p=4, k1=1, k2=100, start_date=c(1991,1)){\n\n  v.neglogPost <- function(theta){\n    N = ncol(data)\n    # p = no. of lags\n    K = 1 + p*N\n    # forecast horizon\n    # h       = 8\n    Y       = ts(data[(p+1):nrow(data),], start=start_date, frequency=4)\n    T = nrow(Y)\n    X       = matrix(1,T,1)\n    # nrow(X)\n    for (i in 1:p){\n      X     = cbind(X,data[(p+1):nrow(data)-i,])\n    }\n    \n    # Calculate MLE for prior \n    ############################################################\n    A.hat       = solve(t(X)%*%X)%*%t(X)%*%Y\n    Sigma.hat   = t(Y-X%*%A.hat)%*%(Y-X%*%A.hat)/nrow(Y)\n    \n    # Specify prior distribution\n    ############################################################\n    kappa.1     = k1\n    kappa.2     = k2\n    kappa.3     = 1\n    A.prior     = matrix(0,nrow(A.hat),ncol(A.hat))\n    A.prior[2:(N+1),] = kappa.3*diag(N)\n    V.prior     = diag(c(kappa.2,kappa.1*((1:p)^(-2))%x%rep(1,N)))\n    S.prior     = diag(diag(Sigma.hat))\n    nu.prior    = N+1\n    \n    vec <- theta[1:3]\n    for (i in 4:12){\n      vec <- c(vec, 1 + (theta[3]-1)*theta[4]^(i-3))\n    }  \n    \n    V <- c(ts(rep(1, nrow(Y)-12), c(1991,1), frequency = 4) , vec)    \n    \n    Y.tilde <- diag(1/V)%*%Y\n    X.tilde <- diag(1/V)%*%X\n    A.tilde.hat <- solve((t(X.tilde)%*%X.tilde+solve(V.prior)))%*%(t(X.tilde)%*%Y.tilde+solve(V.prior)%*%A.prior)\n    epsilon.tilde <-Y.tilde - X.tilde%*%A.tilde.hat\n    \n    # Log-likelihood      \n    logL <- log(prod(V^(-N)))+(-N/2)*log(det(t(X.tilde)%*%X.tilde+solve(V.prior)))+\n            (-(T-p+nu.prior)/2)*log(det(S.prior +t(epsilon.tilde)%*%epsilon.tilde + \n            t(A.tilde.hat-A.prior)%*%solve(V.prior)%*%(A.tilde.hat-A.prior)))\n    \n    # Pareto(1,1) and Beta(3,1.5) priors \n    pareto.a=1\n    pareto.b=1\n    beta.a=3\n    beta.b=1.5\n    beta.cons <- 1/beta(beta.a,beta.b)\n    \n    # Log-prior\n    logP <- log((pareto.a*pareto.b^pareto.a)/(theta[1]^(pareto.a+1))*\n    (pareto.a*pareto.b^pareto.a)/(theta[2]^(pareto.a+1))*\n    (pareto.a*pareto.b^pareto.a)/(theta[3]^(pareto.a+1))*\n    beta.cons*theta[4]^(beta.a-1)*(1-theta[4])^(beta.b-1))\n    \n    # negative log-posterior\n    neglogPost <- -(logL+logP)\n    \n    return(neglogPost)\n  }\n   \n  # numerically minimize the negative log-likelihood\n  post.maximizer <- optim(par=c(50, 50, 50, 0.5), fn=v.neglogPost, method=\"L-BFGS-B\", \n                          lower=c(1, 1, 1, 0.0001),\n                          upper=c(100,100,100,0.99999), hessian = TRUE)\n  \n  return(list(maximizer=post.maximizer$par, hessian=post.maximizer$hessian))\n\n}\n\n\n\nmh.mcmc takes in data, the posterior mode of \\(\\theta\\), and the inverse Hessian from v.posterior.mode to run the above-mentioned Metropolis MCMC algorithm for a specified number of iterations; and\n\n\n\nShow code\nmh.mcmc <- function(data, p=1, S.mh = S.global, c, W = diag(4), theta.init,\n                    k1 = 1, k2 = 100, start_date = c(1991,1)){\n # N = no. of variables\n  N = ncol(data)\n  # p = no. of lags\n  K = 1 + p*N\n  # forecast horizon\n  # h       = 8\n  Y       = ts(data[(p+1):nrow(data),], start=start_date, frequency=4)\n  T = nrow(Y)\n  X       = matrix(1,T,1)\n  # nrow(X)\n  for (i in 1:p){\n    X     = cbind(X,data[(p+1):nrow(data)-i,])\n  }\n  \n\n  # Calculate MLE for prior \n  ############################################################\n  A.hat       = solve(t(X)%*%X)%*%t(X)%*%Y\n  Sigma.hat   = t(Y-X%*%A.hat)%*%(Y-X%*%A.hat)/nrow(Y)\n  \n  # Specify prior distribution\n  ############################################################\n  kappa.1     = k1\n  kappa.2     = k2\n  kappa.3     = 1\n  A.prior     = matrix(0,nrow(A.hat),ncol(A.hat))\n  A.prior[2:(N+1),] = kappa.3*diag(N)\n  V.prior     = diag(c(kappa.2,kappa.1*((1:p)^(-2))%x%rep(1,N)))\n  S.prior     = diag(diag(Sigma.hat))\n  nu.prior    = N+1\n  \n  # Metropolis-Hastings \n  ###########################################################\n  # v0, v1, v2, rho\n  Theta <- matrix(NA,S.mh,4)\n  theta_old <- theta.init\n  #theta_old <- Theta[nrow(Theta),]\n  \n  # W <- diag(4)\n  set.seed(1)\n  for (s in 1:S.mh){\n\n    covid.vec <- function(theta){\n      vec <- theta[1:3]\n      for (i in 4:12){\n        vec <- c(vec, 1 + (theta[3]-1)*theta[4]^(i-3))\n      }\n      \n      return(vec)\n    }\n\n    # Covid volatility likelihood kernel\n    v.logL <- function(V){\n      Y.tilde <- diag(1/V)%*%Y\n      X.tilde <- diag(1/V)%*%X\n      A.tilde.hat <- solve((t(X.tilde)%*%X.tilde+solve(V.prior)))%*%(t(X.tilde)%*%Y.tilde+solve(V.prior)%*%A.prior)\n      epsilon.tilde <-Y.tilde - X.tilde%*%A.tilde.hat\n\n      logL <- log(prod(V^(-N)))+(-N/2)*log(det(t(X.tilde)%*%X.tilde+solve(V.prior)))+\n              (-(T-p+nu.prior)/2)*log(det(S.prior +t(epsilon.tilde)%*%epsilon.tilde + \n              t(A.tilde.hat-A.prior)%*%solve(V.prior)%*%(A.tilde.hat-A.prior)))\n\n      return(logL)\n    }\n  \n    # Covid volatility prior\n    v.logP <- function(theta, pareto.a=1, pareto.b=1, beta.a=3, beta.b=1.5){\n      beta.cons <- 1/beta(beta.a,beta.b)\n  \n      logP <- log((pareto.a*pareto.b^pareto.a)/(theta[1]^(pareto.a+1))*\n      (pareto.a*pareto.b^pareto.a)/(theta[2]^(pareto.a+1))*\n      (pareto.a*pareto.b^pareto.a)/(theta[3]^(pareto.a+1))*\n       beta.cons*theta[4]^(beta.a-1)*(1-theta[4])^(beta.b-1))\n      \n      return(logP)\n    }\n\n    v_ones <- ts(rep(1, nrow(Y)-12), c(1991,1), frequency = 4) \n    V.old <- c(v_ones, covid.vec(theta_old))    \n      \n    # New candidate parameters values\n    theta_new <- mvrnorm(1, theta_old, c*W)\n    V.new <- c(v_ones, covid.vec(theta_new))\n    \n    # Calculate posteriors \n    v.logpost_old <- v.logL(V.old)+v.logP(theta_old)\n    v.logpost_new <- v.logL(V.new)+v.logP(theta_new)\n    \n    # Posterior ratio\n    post.ratio <- exp(v.logpost_new-v.logpost_old)\n    \n    # Acceptance/rejection alpha\n    alpha <- min(1, post.ratio)\n    \n    u_star <- runif(1)\n    \n    if (alpha > u_star){\n      Theta[s,] <- theta_new\n    } else {Theta[s,] <- theta_old}\n    \n    theta_old <- Theta[s,]  \n  }\n  \n  colnames(Theta) <- c(\"h0\", \"h1\" , \"h2\", \"rho\")\n\n  re <- list(Theta=Theta, \n             AcceptRate = 1 - rejectionRate(as.mcmc(Theta[,1])))\n  return(re)\n}\n\n\n\nsign.extension takes in data and draws of \\(\\theta\\) from mh.mcmc to return the posterior draws for the extended model.\n\n\n\nShow code\nsign.extension <- function(data, p=4, S=S.global,  sign.restrictions = c(0, 0, 1, 1, 1, -1, 1, -1, 1),\n                           k1=1, k2=100, shockvar = 5, start_date = c(1991,1), Theta.mh){\n\n  # N = no. of variables\n  N = ncol(data)\n  # p = no. of lags\n  K = 1 + p*N\n  # forecast horizon\n  # h       = 8\n  Y       = ts(data[(p+1):nrow(data),], start=start_date, frequency=4)\n  T = nrow(Y)\n  X       = matrix(1,T,1)\n  # nrow(X)\n  for (i in 1:p){\n    X     = cbind(X,data[(p+1):nrow(data)-i,])\n  }\n  \n  \n  covid.vec <- function(theta){\n    vec <- theta[1:3]\n    for (i in 4:12){\n      vec <- c(vec, 1 + (theta[3]-1)*theta[4]^(i-3))\n    }\n      \n    return(vec)\n  }\n  \n\n  # array of S diag(covid volatility) matrices\n  diagV.sqinv <- array(NA, c(nrow(Y),nrow(Y),S))\n  \n  for (s in 1:S){\n    v_ones <- ts(rep(1, nrow(Y)-12), c(1991,1), frequency = 4) \n    diagV.sqinv[,,s] <- diag(c(v_ones, covid.vec(Theta.mh[s,]))^(-2))\n  }\n  \n  # Calculate MLE for prior \n  ############################################################\n  A.hat       = solve(t(X)%*%X)%*%t(X)%*%Y\n  Sigma.hat   = t(Y-X%*%A.hat)%*%(Y-X%*%A.hat)/nrow(Y)\n\n  # Specify prior distribution\n  ############################################################\n  kappa.1     = k1\n  kappa.2     = k2\n  kappa.3     = 1\n  A.prior     = matrix(0,nrow(A.hat),ncol(A.hat))\n  A.prior[2:(N+1),] = kappa.3*diag(N)\n  V.prior     = diag(c(kappa.2,kappa.1*((1:p)^(-2))%x%rep(1,N)))\n  S.prior     = diag(diag(Sigma.hat))\n  nu.prior    = N+1\n  \n  # Posterior draws \n  ############################################################\n  Sigma.posterior   = array(NA,c(N,N,S))\n  A.posterior       = array (NA,c(K,N,S))\n  B0.posterior       = array(NA,c(N,N,S))\n  Bplus.posterior       = array(NA,c(N,K,S))\n  \n  for (s in 1:S){\n    V.bar.inv   = t(X)%*%diagV.sqinv[,,s]%*%X + diag(1/diag(V.prior))\n    V.bar       = solve(V.bar.inv)\n    A.bar       = V.bar%*%(t(X)%*%diagV.sqinv[,,s]%*%Y + diag(1/diag(V.prior))%*%A.prior)\n    nu.bar      = nrow(Y) + nu.prior\n    S.bar       = S.prior + t(Y)%*%diagV.sqinv[,,s]%*%Y + t(A.prior)%*%diag(1/diag(V.prior))%*%\n                  A.prior - t(A.bar)%*%V.bar.inv%*%A.bar\n    S.bar.inv   = solve(S.bar)\n    L                 = t(chol(V.bar))\n    \n    # RF posterior draws\n    Sigma.posterior[,,s] <- solve(rWishart(1, df=nu.bar, Sigma=S.bar.inv)[,,1])\n    cholSigma.s     = chol(Sigma.posterior[,,s])\n    A.posterior[,,s]       = matrix(mvrnorm(1,as.vector(A.bar), Sigma.posterior[,,s]%x%V.bar),ncol=N)\n    A.posterior[,,s]= A.bar + L%*%A.posterior[,,s]%*%cholSigma.s\n    \n    # SF posterior draws \n    B0.posterior[,,s]= solve(t(cholSigma.s))\n    # Draw Bplus\n    Bplus.posterior[,,s] = B0.posterior[,,s]%*%t(A.posterior[,,s])\n  }\n\n  # Identification via sign restrictions on theta0\n  ############################################################\n\n  # generate corresponding R matrix\n  R1 = diag(sign.restrictions)\n  \n  # storage matrices for Q identified estimates\n  i.vec <- c()\n  Q.iden   = array(NA,c(N,N,S))\n  B0.iden = array(NA,c(N,N,S))\n  B1.iden = array(NA,c(N,K,S))\n  A.iden = array (NA,c(K,N,S))\n  \n  for (s in 1:S){\n    \n    # pick-up a B0 from S\n    B0.tilde <- B0.posterior[,,s]\n    IR.0.tilde    = solve(B0.tilde)\n    B1.tilde      = Bplus.posterior[,,s]\n    #IR.1.tilde    = solve(B0.tilde)%*%B1.tilde%*%solve(B0.tilde)\n\n    # Search for appropriate Q \n    sign.restrictions.do.not.hold = TRUE\n    i=1\n    while (sign.restrictions.do.not.hold){\n      X           = matrix(rnorm(N^2),N,N)\n      QR          = qr(X, tol = 1e-10)\n      Q           = qr.Q(QR,complete=TRUE)\n      R           = qr.R(QR,complete=TRUE)\n      Q           = t(Q %*% diag(sign(diag(R))))\n      B0          = Q%*%B0.tilde\n      B1          = Q%*%B1.tilde\n      B0.inv      = solve(B0)\n      check       = prod(R1 %*% B0.inv %*% diag(N)[,shockvar] >= 0)\n      A           = t(solve(B0)%*%B1)\n\n      if (check==1){sign.restrictions.do.not.hold=FALSE}\n      i=i+1\n    }\n    i.vec <- c(i.vec, i)\n    Q.iden[,,s] <- Q\n    B0.iden[,,s] <- B0\n    B0.mean <- apply(B0.iden,1:2,mean)\n    B1.iden[,,s] <- B1\n    B1.mean <- apply(B1.iden,1:2,mean)\n    A.iden[,,s] <- A\n    A.mean <- apply(A.iden,1:2,mean)\n  }\n\n  re <- list(\"i\" = i.vec, \"Q\" = Q.iden, \"B0\"= B0.iden, \"B0.mean\" = B0.mean,\n             \"Bplus\"= B1.iden, \"Bplus.mean\" = B1.mean, \"A\" = A.iden, \"A.mean\" = A,\n             \"A.posterior\"=A.posterior, \"Sigma.posterior\"=Sigma.posterior, \"Theta\"= Theta.mh)\n  return(re)\n  \n}\n\n\nApplying v.posterior.mode on the artifcial data yielded a mode of \\(\\theta^{(s=1)}=(1,1,1,0.8)\\) which is appropriate given that there is no COVID volatility in generated random walk series. However, the numerical optimization yielded a non-positive definite Hessian which cannot be used to initialize the Metropolis MCMC. As such, \\(W\\) was instead set to an identity matrix.\nRunning mh.mcmc on the artificial data for 15,000 iterations yields the following draws. Unfortunately, the MCMC draws failed to converge into a stationary series within these number of iterations.\n\n\n\n\n\nNonetheless, using these draws in the estimation procedure implemented by sign.extension still yields correct estimates for \\(A\\) and \\(\\Sigma\\), as seen in the results below. Note however, memory capacity of the computer used only allowed for 2000 draws for the extended model.\n(Note: 10,000 draws is possible for estimation using the actual macroeconomic data given the much fewer observations)\n\n\n\n\n  \n\n\n\n\n\n  \n\n\n\nEstimation of the common stochastic volatility model is conducted using the sign.stochvol function below:\n\n\n\nApplying the sign.stochvol on the random walk with drift data for \\(S=10,000\\) draws yields an appropriate identity matrix estimate for \\(A\\). However, the product of the average \\(\\sigma^2\\) and \\(\\Sigma\\) estimates do not yield an identity matrix. This may be due to poor estimation of \\(\\sigma^2\\) as the artificial data does not provide any real signals (i.e., there is no actual conditional heteroskedasticity).\n\n\n\n\n  \n\n\n\n\n\n  \n\n\n\n[1] 2001.257"
  },
  {
    "objectID": "index.html#emperical-investigation",
    "href": "index.html#emperical-investigation",
    "title": "Effects of Fiscal Policy on Unemployment and Output in Australia: a Bayesian SVAR Approach",
    "section": "Emperical investigation",
    "text": "Emperical investigation\nThis section investigates the effect of an exogenous shock to public investment, represented by the public gross fixed capital formation (GFCF, i.e., the 5th variable in the \\(Y\\)). These will be measured through impulse response functions (IRFs) which capture the dynamic causal effects of an exogenous shock \\(u_t\\) on the variables in the system.\nGiven the \\(VAR(1)\\) representation of the model: \\[Y_t &= \\textbf{A}Y_{t-1} + U_t\\] \\[=U_t+\\textbf{A}U_{t-1}+\\textbf{A}^2U_{t-2}+...\\] Transforming back to a \\(VAR(p)\\) representation using the \\(J\\) matrix:\n\\[J=\\big[I_n\\quad 0_{N\\times N(p-1)}\\big]\\]\n\\[y_t =JY_t=JU_t+J\\textbf{A}J'JU_{t-1}+J\\textbf{A}^2J'JU_{t-2}+...\\] \\[=u_t+J\\textbf{A}J'u_{t-1}+J\\textbf{A}^2J'u_{t-2}\\]"
  },
  {
    "objectID": "index.html#empirical-investigation",
    "href": "index.html#empirical-investigation",
    "title": "Effects of Fiscal Policy on Unemployment and Output in Australia: a Bayesian SVAR Approach",
    "section": "Empirical investigation",
    "text": "Empirical investigation\nThis section investigates the effect of an exogenous shock to public investment, represented by the public gross fixed capital formation (GFCF, i.e., the 5th variable in the \\(Y\\)). These will be measured through impulse response functions (IRFs) which capture the dynamic causal effects of an exogenous shock \\(u_t\\) on the variables in the system.\nGiven the \\(VAR(1)\\) representation of the model: \\[Y_t = \\textbf{A}Y_{t-1} + E_t\\] \\[=E_t+\\textbf{A}E_{t-1}+\\textbf{A}^2E_{t-2}+...\\] Transforming back to a \\(VAR(p)\\) representation using the \\(J\\) matrix:\n\\[J=\\big[I_n\\quad 0_{N\\times N(p-1)}\\big]\\]\n\\[y_t =JY_t=JE_t+J\\textbf{A}J'JE_{t-1}+J\\textbf{A}^2J'JE_{t-2}+...\\] \\[=\\varepsilon_t+J\\textbf{A}J'\\varepsilon_{t-1}+J\\textbf{A}^2J'\\varepsilon_{t-2}+...\\] Substituting \\(\\varepsilon_t=Bu_t\\):\n\\[y_t =Bu_t+J\\textbf{A}J'Bu_{t-1}+J\\textbf{A}^2J'Bu_{t-2}+...\\] \\[=\\Theta_0u_t+\\Theta_1u_{t-1}+\\Theta_2u_{t-2}+...\\]Where matrix \\(\\frac{\\partial y_{t+i}}{\\partial u_t}=\\Theta_i\\) is the IRF which characterizes the effect of the variables \\(y_t\\), \\(i\\) periods from impact.\nThe above derivations are implemented in the function irf.plot below, which takes in draws of \\(A\\) and \\(B_0\\) and does the necessary transformations estimate and plot the impluse response functions for a shock on a specified variable.\n\n\nShow code\nirf.plot <- function(A.posterior, B0.posterior, shock.var, p=4, h = 12,\n                     varnames = varname_vec){\n  # Define colors\n  ############################################################\n  mcxs1  = \"#05386B\"\n  mcxs2  = \"#379683\"\n  mcxs3  = \"#5CDB95\"\n  mcxs4  = \"#8EE4AF\"\n  mcxs5  = \"#EDF5E1\"\n  purple = \"#b02442\"\n  \n  mcxs1.rgb   = col2rgb(mcxs1)\n  mcxs1.shade1= rgb(mcxs1.rgb[1],mcxs1.rgb[2],mcxs1.rgb[3], alpha=120, maxColorValue=255)\n  mcxs2.rgb   = col2rgb(mcxs2)\n  mcxs2.shade1= rgb(mcxs2.rgb[1],mcxs2.rgb[2],mcxs2.rgb[3], alpha=120, maxColorValue=255)\n  \n  # Impulse response functions\n  ############################################################\n  N <- dim(A.posterior)[2]\n  S <- dim(A.posterior)[3]\n  \n  # transform B0 matrices to B\n  B.posterior <- array(NA, c(N,N,S))\n  for (s in 1:S){\n  B.posterior[,,s] <- solve(B0.posterior[,,s])\n  }\n  \n  IRF.posterior     = array(NA,c(N,N,h+1,S))\n  IRF.inf.posterior = array(NA,c(N,N,S))\n  J                 = cbind(diag(N),matrix(0,N,N*(p-1)))\n  \n  for (s in 1:S){\n    # define A matrix in VAR(1) representation\n    A.bold          = rbind(t(A.posterior[2:(1+N*p),,s]),cbind(diag(N*(p-1)),matrix(0,N*(p-1),N)))\n    IRF.inf.posterior[,,s]          = J %*% solve(diag(N*p)-A.bold) %*% t(J) %*% B.posterior[,,s]\n    A.bold.power    = A.bold\n    for (i in 1:(h+1)){\n      if (i==1){\n        IRF.posterior[,,i,s]        = B.posterior[,,s]\n      } else {\n        IRF.posterior[,,i,s]        = J %*% A.bold.power %*% t(J) %*% B.posterior[,,s]\n        A.bold.power                = A.bold.power %*% A.bold\n      }\n    }\n  }\n  \n  # save IRFs\n  save(IRF.posterior,IRF.inf.posterior, file=\"irf-k1.RData\")\n\n  # IRF plots GFCF\n  ############################################################\n  IRFs.k1           = apply(IRF.posterior[,shock.var,,],1:2,mean)\n  IRFs.inf.k1       = apply(IRF.inf.posterior[,shock.var,],1,mean)\n  rownames(IRFs.k1) = varnames\n  \n  IRFs.k1.hdi    = apply(IRF.posterior[,shock.var,,],1:2,hdi, credMass=0.68)\n  hh          = 1:(h+1)\n  \n  par(mfrow=c(3,3), mar=c(3,3,2,2),cex.axis=1.5, cex.lab=1.5)\n  for (n in 1:N){\n    ylims     = range(IRFs.k1[n,hh],IRFs.k1.hdi[,n,hh])\n    plot(hh,IRFs.k1[n,hh], type=\"l\", ylim=ylims, axes=FALSE, xlab=\"3 years\",\n         main=rownames(IRFs.k1)[n])\n    abline(h = 0, col = \"firebrick\")\n    axis(2,c(ylims[1],0,ylims[2]),round(c(ylims[1],0,ylims[2]),3))\n    polygon(c(hh,(h+1):1), c(IRFs.k1.hdi[1,n,hh],IRFs.k1.hdi[2,n,(h+1):1]),\n            col=mcxs1.shade1,border=mcxs1.shade1)\n    lines(hh, IRFs.k1[n,hh],lwd=2,col=mcxs1)\n  }\n}\n\n\n\nBasic model estimation and IRFs\nThe basic model is used to investigate the dynamic effects of shock to public investment on the economic system. Identification proceeds via the following sign restrictions on \\(\\Theta_0\\):\n\\[f(B_0,B_+)=\\Theta_0=B=\\begin{bmatrix}\n* & * & * & * & * & * & * & * & *\\\\\n* & * & * & * & * & * & * & * & *\\\\\n+ & * & * & * & * & * & * & * & *\\\\\n+ & * & * & * & * & * & * & * & *\\\\\n+ & * & * & * & * & * & * & * & *\\\\\n+ & * & * & * & * & * & * & * & *\\\\\n+ & * & * & * & * & * & * & * & *\\\\\n- & * & * & * & * & * & * & * & *\\\\\n+ & * & * & * & * & * & * & * & *\\\\\n\\end{bmatrix}\\]\nwhich corresponds to the following \\(\\textbf{R}_5\\) matrix: \\[\\textbf{R}_5=\\begin{bmatrix}\n0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\\n0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\\n0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\\\\n0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\\\\n0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\\\\\n0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\\\\n0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\\\\n0 & 0 & 0 & 0 & 0 & 0 & 0 & -1 & 0\\\\\n0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\\\\\n\\end{bmatrix}\\]\n\\[\\textbf{R}_5f(B_0,B_+)e_5\\geq0\\]\nWhere the identifying fiscal policy impulse vector is: \\[\\text{diag}(\\textbf{R}_5)=[0\\quad0\\quad1\\quad1\\quad1\\quad1\\quad1\\quad-1\\quad1]\\] \\(\\text{diag}(\\textbf{R}_5)\\) represents an exogenous shock to public investment to which other fiscal variables respond positively and are accommodated by monetary policy. This scenario is applicable, for example during situations where the Australian economy is experiencing low inflation but sluggish growth which the government may want to stimulate in the short-to-medium term. Variables for unemployment and output, the first and second variables in \\(y_t\\), respectively, are left unrestricted as these are the variables whose responses are of interest.\n\n\nShow code\nbasic.model <- sign.basic(lnY.df_num,p=4, S=S.global, c(0, 0, 1, 1, 1, 1, 1, -1, 1), k1 = 1, shockvar=5)\n\nirf.plot(A.posterior = basic.model$A.posterior, B0.posterior = basic.model$B0, shock.var = 5)\n\n\n\n\n\nAs seen in the above plots, an exogenous shock to public investment (i.e., government GFCF) at period \\(h=0\\) is estimated to increase real GDP in subsequent periods, with the majority of estimated real GDP impulse responses at \\(h>0\\) above the zero level. This expansion in output is accompanied by a decrease in unemployment. These results are consistent with the Keynesian economic theory that expansionary fiscal policy (through increased spending) increases output and employment. Note that these improvements to GDP and unemployment occur despite increases in tax revenue.\n\n\nCOVID volatility model estimation and IRFs\nThe same sign restrictions are used for identification in the COVID volatility model. Functions v.posterior and mh.mcmc are implemented to draw vector \\(H\\) based on the macroeconomic data. As seen in the plots below, the Metropolis MCMC also failed to converge to stationarity after 20,000 draws.\n\n\nShow code\nextension.post.mode <- v.posterior.mode(lnY.df_num, p = 4, k1 = 1, k2 = 100)\nset.seed(1)\nextension.mcmc <-mh.mcmc(lnY.df_num, p=4, c=0.000228, W = solve(extension.post.mode$hessian), \n                theta.init = extension.post.mode$maximizer, k1 = 1, S.mh = 2*S.global)\nplot.ts(extension.mcmc$Theta, main = \"Metropolis MCMC draws\", xlab = \"\")\n\n\n\n\n\nThe resulting IRF plots from the extended model mimic the basic model results where an exogenous shock to GFCF results in higher output and lower unemployment rates. However, the bands surrounding the mean line of the IRFs have become slightly tighter, as accounting for COVID-induced conditional heteroskedasticity effectively down-weights the heightened volatility of observations during the pandemic.\n\n\n\n\n\nMoreover, estimates suggest that conditional volatility peaked during Q2 2020, sharply declined in the subsequent quarter and linearly decaying thereafter. These results do not seem to be realistic.\n\n\n\n\n\n\n\nCommon stochastic volatility model estimation and IRFs\nLastly, the common SV model was ran on the macroeconomic data and yields the following IRFs. By and large, the general location of the mean lines are similar to the basic and COVID-volatility model, though the estimated effect of fiscal policy on output has become negative to near zero. We also note that surrounding bands around the mean have become much narrower in this model.\n\n\n\n\n\nMoreover, the \\(\\sigma\\) estimates provide a more realistic picture of the conditional volatility across the time series. As seen in the plot below, the common SV model not only captures the heightened volatility during COVID, but also the spikes in uncertainty during the Asian financial crisis and the global financial crisis."
  },
  {
    "objectID": "index.html#conclusion-and-possible-extensions",
    "href": "index.html#conclusion-and-possible-extensions",
    "title": "Effects of Fiscal Policy on Unemployment and Output in Australia: a Bayesian SVAR Approach",
    "section": "Conclusion and possible extensions",
    "text": "Conclusion and possible extensions\nResults across three models suggest that expansionary fiscal policy has some negative effect on unemployment, particularly in the short-to-medium term, which is consistent with the Keynesian framework. The basic and COVID volatility models also corroborate the expected positive effect on output, though this is dampened by the results from the common SV model. Lastly, the results suggest that the simple SV model may be a more practical and effective means of estimating conditional macroeconomic volatility, as it is able to capture heteroskedasticity across the time series (not just during COVID) while also being much easier to implement.\nWe note that identification via sign restrictions was not able to successfully isolate the shocks of any one particular fiscal instrument. As such, an alternative identification strategy that mixes both exclusion and sign restrictions may be more appropriate for this objective. Moreover, given that the Metropolis MCMC failed to converge for both the artificial and actual data, the use of a Hamiltonian MCMC may be explored as this may be more computationally stable and successful in implementing the COVID volatility model."
  },
  {
    "objectID": "index.html#appendix-sample-histograms-of-select-parameters",
    "href": "index.html#appendix-sample-histograms-of-select-parameters",
    "title": "Effects of Fiscal Policy on Unemployment and Output in Australia: a Bayesian SVAR Approach",
    "section": "Appendix: Sample histograms of select parameters",
    "text": "Appendix: Sample histograms of select parameters"
  },
  {
    "objectID": "index.html#appendix-sample-histograms-of-selected-parameters",
    "href": "index.html#appendix-sample-histograms-of-selected-parameters",
    "title": "Effects of Fiscal Policy on Unemployment and Output in Australia: a Bayesian SVAR Approach",
    "section": "Appendix: Sample histograms of selected parameters",
    "text": "Appendix: Sample histograms of selected parameters"
  }
]